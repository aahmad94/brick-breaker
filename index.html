<!DOCTYPE html>
<html lang="en">
    <head>
        <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
        <meta content="utf-8" http-equiv="encoding">
    </head>
    <body>
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <script>
            let ballX = 75;
            let ballSpeedX = 2.5;
            let ballY = 75;
            let ballSpeedY = 2.5;
            let canvas, ctx;

            let mouseX = 0;
            let mouseY = 0;

            const PADDLE_WIDTH = 100;
            const PADDLE_THICKNESS = 10;
            const PADDLE_DIST_FROM_EDGE = 60;
            var paddleX = 400;

            const BRICK_W = 80;
            const BRICK_H = 20;
            const BRICK_GAP = 2;
            const BRICK_COLS = 10;
            const BRICK_ROWS = 14;

            let brickGrid = new Array(BRICK_COLS * BRICK_ROWS);

            const rowColToArrIdx = (col, row) => {
                return col + BRICK_COLS * row;
            }

            const drawBricks = () => {
                for (let row = 0; row < BRICK_ROWS; row++) {
                    for (let col = 0; col < BRICK_COLS; col++) {
                        let arrIdx = rowColToArrIdx(col, row);
                        if (brickGrid[arrIdx]) {
                            colorRect(BRICK_W * col, BRICK_H * row, BRICK_W - BRICK_GAP, BRICK_H - BRICK_GAP, 'blue');
                        }
                    }
                }
            }

            const brickReset = () => {
                for (let brick = 0; brick < BRICK_COLS * BRICK_ROWS; brick++) {
                    if (0 < 0.5) {
                        brickGrid[brick] = true;
                    } else {
                        brickGrid[brick] = false;
                    }
                }
            }

            const updateMousePos = (e) => {
                let rect = canvas.getBoundingClientRect();
                let root = document.documentElement;                
                mouseX = e.clientX - rect.left - root.scrollLeft;
                mouseY = e.clientY - rect.top - root.scrollTop;
                paddleX = mouseX - PADDLE_WIDTH/2;
            }

            window.onload = () => {
                canvas = document.getElementById('gameCanvas');
                ctx = canvas.getContext('2d');

                let framesPerSecond = 60;
                setInterval(updateAll, 1000/framesPerSecond);

                canvas.addEventListener('mousemove', updateMousePos); 
                brickReset();               
            }

            const updateAll = () => {
                moveAll();
                drawAll();
            }

            const resetBall = () => {
                ballX = canvas.width/2;
                ballY = canvas.height/2;
            }
                
            const moveAll = () => {
                ballX += ballSpeedX;
                ballY += ballSpeedY;
                if (ballX < 0) { // left
                    ballSpeedX *= -1;
                }
                if (ballX > canvas.width) { // right
                    ballSpeedX *= -1;
                }
                if (ballY < 0) { // top
                    ballSpeedY *= -1;
                }
                if (ballY > canvas.height) { // bottom
                    resetBall();
                }

                let paddleLeftEdgeX = paddleX;
                let paddleRightEdgeX = paddleX + PADDLE_WIDTH ;
                let paddleTopEdgeY = canvas.height - PADDLE_DIST_FROM_EDGE;
                let paddleBottomEdgeY = paddleTopEdgeY + PADDLE_THICKNESS;

                let ballBrickCol = Math.floor(ballX / BRICK_W);
                let ballBrickRow = Math.floor(ballY / BRICK_H);
                let brickIdxUnderBall = rowColToArrIdx(ballBrickCol, ballBrickRow);
                if (ballBrickCol >= 0 && ballBrickCol < BRICK_COLS && 
                    ballBrickRow >= 0 && ballBrickRow < BRICK_ROWS) {
                        brickGrid[brickIdxUnderBall] = false;
                }


                if (ballX > paddleLeftEdgeX &&
                    ballX < paddleRightEdgeX && 
                    ballY > paddleTopEdgeY && 
                    ballY < paddleBottomEdgeY) {
                        ballSpeedY *= -1;
                        let centerOfPaddleX = paddleX + PADDLE_WIDTH/2;
                        let ballDistFromPaddleCenterX = ballX - centerOfPaddleX;
                        ballSpeedX = ballDistFromPaddleCenterX * 0.35; 
                    }
            }

            const drawAll = () => {
                colorRect(0, 0, canvas.width, canvas.height, "black"); // canvas
                colorCircle(ballX, ballY, 10, "white"); // pong ball
                colorRect(paddleX, canvas.height - PADDLE_DIST_FROM_EDGE, PADDLE_WIDTH, PADDLE_THICKNESS, "white");
                drawBricks();
            }
            
            const colorRect = (topLeftX, topLeftY, boxWidth, boxHeight, fillColor) => {
                ctx.fillStyle = fillColor;
                ctx.fillRect(topLeftX, topLeftY, boxWidth, boxHeight);
            }

            const colorCircle = (centerX, centerY, radius, fillColor) => {
                ctx.fillStyle = fillColor;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI*2);
                ctx.fill();
            }

            const colorText = (showWords, textX, textY, fillColor) => {
                ctx.fillStyle = fillColor;
                ctx.fillText(showWords, textX, textY);
            }

        </script>
    </body>
</html>